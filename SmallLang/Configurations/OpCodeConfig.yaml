HighLevelOpcodes:
  namespace: SmallLang.IR.LinearIR
  usings: [Common.LinearIR, System.Numerics]
  generator: highlevelopcodes.py
  dst: IR/LinearIR/Generated/
  display name: "Generate-High-Level-Opcodes"

  name:
    enum: HighLevelOpcode
    record: HighLevelOperation

  data:
    - name: NOp
      arguments: []
      comment: NOp
    - name: Jump
      arguments:
        - name: Chunk0
      comment: Jumps unconditionally to the chunk given by the chunk-id

    - name: BranchZero
      arguments:
        - name: ChunkIf0
        - name: ChunkIfNot0
      comment: Jumps to ChunkIf0 if the value at the top of the stack is 0, else ChunkIfNot0

    - name: Return
      arguments: []
      comment: Returns control to the calling chunk. Return values should be on the stack.

    - name: Switch
      arguments:
        - name: Expression1Register
        - name: Length
        - name: StartingIndex
        - name: TypeCode
      comment: >
        SWITCH Length StartIndex, select the correct instruction(s) based on the TypeCode.
        Stores all the computed expressions in contiguous registers, and the expression being switched on goes in Expression1Register

    - name: IfNoElse
      arguments:
        - name: StartingIndex
        - name: Length
      comment: >
        For i in [1...Length]:
          run CHUNKS[i * 2 - 1].
          If (POP) is TRUE:
            run CHUNKS[i * 2].
            jump to CHUNKS[Length * 2 + 1].
        Finally jump to CHUNKS[Length * 2 + 1].

    - name: IfElse
      arguments:
        - name: StartingIndex
        - name: Length
      comment: >
        For i in [1...Length]:
          run CHUNKS[i * 2 - 1].
          If (POP) is TRUE:
            run CHUNKS[i * 2].
            jump to CHUNKS[Length * 2 + 2].
        Finally jump to CHUNKS[Length * 2 + 1].


    - name: Push
      arguments:
        - name: Value
      comment: Pushes an inline constant number onto the stack.


    - name: Factorial
      arguments:
        - name: SrcRegisterStart
        - name: DstRegisterStart
        - name: Type
        - name: ExclamationCount
      comment: Computes factorial. Supports multiple exclamation marks.
    
    - name: Break
      arguments:
        - name: Condition
        - name: Epilogue
        - name: Main
        - name: Else
        - name: Next
      comment: Break jumps to Next
    - name: Continue
      arguments:
        - name: Condition
        - name: Epilogue
        - name: Main
        - name: Else
        - name: Next
      comment: Continue takes over control of the loop as provided.
    - name: Loop
      arguments:
        - name: Condition
        - name: Epilogue
        - name: Main
        - name: Else
        - name: Next
      comment: >
        runs the loop. 
          while(Condition results in top of stack being true)
            run Main
            run Epilogue
          
          if loop terminated naturally:
            run Else
          
          run Next
    - name: LoadFromStack
      arguments:
        - name: DestinationRegister
        - name: Width
      comment: Loads a value from the stack into the registers beginning at DestinationRegister
    


  
